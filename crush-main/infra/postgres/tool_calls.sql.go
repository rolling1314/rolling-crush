// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tool_calls.sql

package postgres

import (
	"context"
	"database/sql"
)

const createToolCall = `-- name: CreateToolCall :one
INSERT INTO tool_calls (
    id,
    session_id,
    message_id,
    name,
    input,
    status,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, EXTRACT(EPOCH FROM NOW()) * 1000, EXTRACT(EPOCH FROM NOW()) * 1000
)
RETURNING id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at
`

type CreateToolCallParams struct {
	ID        string         `json:"id"`
	SessionID string         `json:"session_id"`
	MessageID sql.NullString `json:"message_id"`
	Name      string         `json:"name"`
	Input     sql.NullString `json:"input"`
	Status    string         `json:"status"`
}

func (q *Queries) CreateToolCall(ctx context.Context, arg CreateToolCallParams) (ToolCall, error) {
	row := q.queryRow(ctx, q.createToolCallStmt, createToolCall,
		arg.ID,
		arg.SessionID,
		arg.MessageID,
		arg.Name,
		arg.Input,
		arg.Status,
	)
	var i ToolCall
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.MessageID,
		&i.Name,
		&i.Input,
		&i.Status,
		&i.Result,
		&i.IsError,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getToolCall = `-- name: GetToolCall :one
SELECT id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at FROM tool_calls
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetToolCall(ctx context.Context, id string) (ToolCall, error) {
	row := q.queryRow(ctx, q.getToolCallStmt, getToolCall, id)
	var i ToolCall
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.MessageID,
		&i.Name,
		&i.Input,
		&i.Status,
		&i.Result,
		&i.IsError,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const listToolCallsBySession = `-- name: ListToolCallsBySession :many
SELECT id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at FROM tool_calls
WHERE session_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListToolCallsBySession(ctx context.Context, sessionID string) ([]ToolCall, error) {
	rows, err := q.query(ctx, q.listToolCallsBySessionStmt, listToolCallsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.MessageID,
			&i.Name,
			&i.Input,
			&i.Status,
			&i.Result,
			&i.IsError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolCallsByMessage = `-- name: ListToolCallsByMessage :many
SELECT id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at FROM tool_calls
WHERE message_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListToolCallsByMessage(ctx context.Context, messageID sql.NullString) ([]ToolCall, error) {
	rows, err := q.query(ctx, q.listToolCallsByMessageStmt, listToolCallsByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.MessageID,
			&i.Name,
			&i.Input,
			&i.Status,
			&i.Result,
			&i.IsError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingToolCalls = `-- name: ListPendingToolCalls :many
SELECT id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at FROM tool_calls
WHERE session_id = $1 AND status IN ('pending', 'running')
ORDER BY created_at ASC
`

func (q *Queries) ListPendingToolCalls(ctx context.Context, sessionID string) ([]ToolCall, error) {
	rows, err := q.query(ctx, q.listPendingToolCallsStmt, listPendingToolCalls, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.MessageID,
			&i.Name,
			&i.Input,
			&i.Status,
			&i.Result,
			&i.IsError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolCallStatus = `-- name: UpdateToolCallStatus :exec
UPDATE tool_calls
SET
    status = $1,
    started_at = CASE WHEN $1 = 'running' AND started_at IS NULL THEN EXTRACT(EPOCH FROM NOW()) * 1000 ELSE started_at END,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $2
`

type UpdateToolCallStatusParams struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

func (q *Queries) UpdateToolCallStatus(ctx context.Context, arg UpdateToolCallStatusParams) error {
	_, err := q.exec(ctx, q.updateToolCallStatusStmt, updateToolCallStatus, arg.Status, arg.ID)
	return err
}

const updateToolCallInput = `-- name: UpdateToolCallInput :exec
UPDATE tool_calls
SET
    input = $1,
    status = CASE WHEN status = 'pending' THEN 'running' ELSE status END,
    started_at = CASE WHEN started_at IS NULL THEN EXTRACT(EPOCH FROM NOW()) * 1000 ELSE started_at END,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $2
`

type UpdateToolCallInputParams struct {
	Input sql.NullString `json:"input"`
	ID    string         `json:"id"`
}

func (q *Queries) UpdateToolCallInput(ctx context.Context, arg UpdateToolCallInputParams) error {
	_, err := q.exec(ctx, q.updateToolCallInputStmt, updateToolCallInput, arg.Input, arg.ID)
	return err
}

const updateToolCallResult = `-- name: UpdateToolCallResult :exec
UPDATE tool_calls
SET
    result = $1,
    is_error = $2,
    error_message = $3,
    status = CASE WHEN $2 THEN 'error' ELSE 'completed' END,
    finished_at = EXTRACT(EPOCH FROM NOW()) * 1000,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $4
`

type UpdateToolCallResultParams struct {
	Result       sql.NullString `json:"result"`
	IsError      bool           `json:"is_error"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateToolCallResult(ctx context.Context, arg UpdateToolCallResultParams) error {
	_, err := q.exec(ctx, q.updateToolCallResultStmt, updateToolCallResult, arg.Result, arg.IsError, arg.ErrorMessage, arg.ID)
	return err
}

const cancelToolCall = `-- name: CancelToolCall :exec
UPDATE tool_calls
SET
    status = 'cancelled',
    finished_at = EXTRACT(EPOCH FROM NOW()) * 1000,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $1 AND status IN ('pending', 'running')
`

func (q *Queries) CancelToolCall(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.cancelToolCallStmt, cancelToolCall, id)
	return err
}

const cancelSessionToolCalls = `-- name: CancelSessionToolCalls :exec
UPDATE tool_calls
SET
    status = 'cancelled',
    finished_at = EXTRACT(EPOCH FROM NOW()) * 1000,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE session_id = $1 AND status IN ('pending', 'running')
`

func (q *Queries) CancelSessionToolCalls(ctx context.Context, sessionID string) error {
	_, err := q.exec(ctx, q.cancelSessionToolCallsStmt, cancelSessionToolCalls, sessionID)
	return err
}

const deleteToolCall = `-- name: DeleteToolCall :exec
DELETE FROM tool_calls
WHERE id = $1
`

func (q *Queries) DeleteToolCall(ctx context.Context, id string) error {
	_, err := q.exec(ctx, q.deleteToolCallStmt, deleteToolCall, id)
	return err
}

const deleteSessionToolCalls = `-- name: DeleteSessionToolCalls :exec
DELETE FROM tool_calls
WHERE session_id = $1
`

func (q *Queries) DeleteSessionToolCalls(ctx context.Context, sessionID string) error {
	_, err := q.exec(ctx, q.deleteSessionToolCallsStmt, deleteSessionToolCalls, sessionID)
	return err
}

const updateToolCallAwaitingPermission = `-- name: UpdateToolCallAwaitingPermission :exec
UPDATE tool_calls
SET
    status = 'awaiting_permission',
    permission_requested_at = EXTRACT(EPOCH FROM NOW()) * 1000,
    original_prompt = $2,
    permission_action = $3,
    permission_path = $4,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $1
`

type UpdateToolCallAwaitingPermissionParams struct {
	ID               string         `json:"id"`
	OriginalPrompt   sql.NullString `json:"original_prompt"`
	PermissionAction sql.NullString `json:"permission_action"`
	PermissionPath   sql.NullString `json:"permission_path"`
}

func (q *Queries) UpdateToolCallAwaitingPermission(ctx context.Context, arg UpdateToolCallAwaitingPermissionParams) error {
	_, err := q.db.ExecContext(ctx, updateToolCallAwaitingPermission,
		arg.ID,
		arg.OriginalPrompt,
		arg.PermissionAction,
		arg.PermissionPath,
	)
	return err
}

const listAwaitingPermissionToolCalls = `-- name: ListAwaitingPermissionToolCalls :many
SELECT id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at, permission_requested_at, original_prompt, permission_action, permission_path FROM tool_calls
WHERE session_id = $1 AND status = 'awaiting_permission'
ORDER BY permission_requested_at ASC
`

func (q *Queries) ListAwaitingPermissionToolCalls(ctx context.Context, sessionID string) ([]ToolCall, error) {
	rows, err := q.db.QueryContext(ctx, listAwaitingPermissionToolCalls, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.MessageID,
			&i.Name,
			&i.Input,
			&i.Status,
			&i.Result,
			&i.IsError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.PermissionRequestedAt,
			&i.OriginalPrompt,
			&i.PermissionAction,
			&i.PermissionPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolCallPermissionGranted = `-- name: UpdateToolCallPermissionGranted :exec
UPDATE tool_calls
SET
    status = 'running',
    started_at = CASE WHEN started_at IS NULL THEN EXTRACT(EPOCH FROM NOW()) * 1000 ELSE started_at END,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $1 AND status = 'awaiting_permission'
`

func (q *Queries) UpdateToolCallPermissionGranted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateToolCallPermissionGranted, id)
	return err
}

const updateToolCallPermissionTimeout = `-- name: UpdateToolCallPermissionTimeout :exec
UPDATE tool_calls
SET
    status = 'timeout',
    error_message = 'Permission request timed out',
    is_error = true,
    finished_at = EXTRACT(EPOCH FROM NOW()) * 1000,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE id = $1 AND status = 'awaiting_permission'
`

func (q *Queries) UpdateToolCallPermissionTimeout(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateToolCallPermissionTimeout, id)
	return err
}

const listTimedOutPermissionRequests = `-- name: ListTimedOutPermissionRequests :many
SELECT id, session_id, message_id, name, input, status, result, is_error, error_message, created_at, updated_at, started_at, finished_at, permission_requested_at, original_prompt, permission_action, permission_path FROM tool_calls
WHERE status = 'awaiting_permission' 
  AND permission_requested_at IS NOT NULL
  AND permission_requested_at < (EXTRACT(EPOCH FROM NOW()) * 1000 - $1)
ORDER BY permission_requested_at ASC
`

func (q *Queries) ListTimedOutPermissionRequests(ctx context.Context, timeoutMs int64) ([]ToolCall, error) {
	rows, err := q.db.QueryContext(ctx, listTimedOutPermissionRequests, timeoutMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolCall{}
	for rows.Next() {
		var i ToolCall
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.MessageID,
			&i.Name,
			&i.Input,
			&i.Status,
			&i.Result,
			&i.IsError,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.PermissionRequestedAt,
			&i.OriginalPrompt,
			&i.PermissionAction,
			&i.PermissionPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const cancelAwaitingPermissionToolCalls = `-- name: CancelAwaitingPermissionToolCalls :exec
UPDATE tool_calls
SET
    status = 'cancelled',
    finished_at = EXTRACT(EPOCH FROM NOW()) * 1000,
    updated_at = EXTRACT(EPOCH FROM NOW()) * 1000
WHERE session_id = $1 AND status = 'awaiting_permission'
`

func (q *Queries) CancelAwaitingPermissionToolCalls(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, cancelAwaitingPermissionToolCalls, sessionID)
	return err
}
